% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Bandersnatch VRF-AD Specification},
  pdfauthor={Seyed Hosseini; Davide Galassi},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Bandersnatch VRF-AD Specification}
\author{Seyed Hosseini \and Davide Galassi}
\date{}

\begin{document}
\maketitle

Draft 2 - 04-04-2024

\newcommand{\G}{\langle G \rangle}
\newcommand{\F}{\mathbb{Z}^*_r}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{introduction}{%
\section{1. Introduction}\label{introduction}}

\textbf{Definition}: A \emph{verifiable random function with additional
data (VRF-AD)} can be described with two functions:

\begin{itemize}
\tightlist
\item
  \(Sign(sk,msg,ad) \mapsto \pi\) : from a secret key \(sk\), an input
  \(msg\), and additional data \(ad\), and returns a signature \(\pi\).
\item
  \(Verify(pk,msg,ad,\pi) \mapsto (out|prep)\) : for a public key
  \(pk\), an input \(msg\), additional data \(ad\), and VRF signature
  \(\pi\) returns either an output \(out\) or else a failure \(perp\).
\end{itemize}

\textbf{Definition}: For an elliptic curve \(E\) defined over finite
field \(\mathbb{F}_p\) with large subgroup \(\langle G \rangle\) with
prime order \(r\) generated by the base point \(G\), an EC-VRF is VRF-AD
where \(pk = sk \cdot G\) and VRF \(Sign\) is based on an elliptic curve
signature scheme.

All VRFs described in this specification are EC-VRF.

\hypertarget{preliminaries}{%
\section{2. Preliminaries}\label{preliminaries}}

\hypertarget{vrf-input}{%
\subsection{2.1. VRF Input}\label{vrf-input}}

A point in \(\langle G \rangle\) and generated using a \(msg\)
octet-string via the \emph{Elligator 2} \emph{hash-to-curve} algorithm
described by section 6.8.2 of
\href{https://datatracker.ietf.org/doc/rfc9380/}{RFC9380}.

Refer to {[}Bandersnatch Cipher Suite{]} for configuration details.

\hypertarget{vrf-output}{%
\subsection{2.2. VRF Output}\label{vrf-output}}

A point in \(G\) generated using VRF input point as:
\(Output \leftarrow sk \cdot Input\).

\hypertarget{vrf-hashed-output}{%
\subsection{2.3. VRF Hashed Output}\label{vrf-hashed-output}}

A fixed length octet-string generated using VRF output point.

The generation procedure details are specified by the proof-to-hash
procedure in section 5.2 of
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} and the output
length depends on the used hasher

Refer to {[}Bandersnatch Cipher Suite{]} for configuration details.

\hypertarget{ietf-vrf}{%
\section{3. IETF VRF}\label{ietf-vrf}}

Definition of a VRF based on the IETF
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} specification.

This VRF faithfully follows the RFC but extends it with the capability
to sign additional user data (\texttt{ad}) as per our definition of
VRF-AD.

In particular, \emph{step 5} of RFC section 5.4.3 is defined as:

\begin{verbatim}
str = str || ad || challenge_generation_domain_separator_back
\end{verbatim}

\hypertarget{sign}{%
\subsection{3.1. Sign}\label{sign}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(sk\): secret key \(\in \mathbb{Z}^*_r\)
\item
  \(input\): \(Input \in \langle G \rangle\)
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Outputs}:

\begin{itemize}
\tightlist
\item
  \(output\): \(Output \in \langle G \rangle\)
\item
  \(proof\): A \emph{Schnorr-like} proof
  \(\in (\mathbb{Z}^*_r, \mathbb{Z}^*_r)\)
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(preout = sk \cdot input\)
\item
  \(k \leftarrow Nonce(sk, input)\)
\item
  \(c \leftarrow Challenge(Y, H, preout, k \cdot B, k \cdot input)\)
\item
  \(s \leftarrow (k + c \cdot x)\)
\item
  \(proof \leftarrow (c, s)\)
\item
  \textbf{return} \((preout, proof)\)
\end{enumerate}

\textbf{Externals}:

\begin{itemize}
\tightlist
\item
  \(Nonce\): refer to
  \href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} section
  5.4.2
\item
  \(Challenge\): refer to
  \href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} section
  5.4.3
\end{itemize}

\hypertarget{verify}{%
\subsection{3.2. Verify}\label{verify}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(pk\): public key \(\in \langle G \rangle\)
\item
  \(input\): \(Input \in \langle G \rangle\)
\item
  \(ad\): Additional data octet-string
\item
  \(output\): \(Output \in \langle G \rangle\)
\item
  \(proof\): as defined for \(Sign\) output.
\end{itemize}

\textbf{Outputs}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(U = s \cdot K - c \cdot pk\)
\item
  \(V = s \cdot H - c \cdot preout\)
\item
  \(c' = Challenge(pk, input, output, U, V)\)
\item
  \textbf{if} \(c \neq c'\) \textbf{then} \textbf{return} False
\item
  \textbf{return} True
\end{enumerate}

\textbf{Externals}:

\begin{itemize}
\tightlist
\item
  \(Challenge\): as defined for \(Sign\)
\end{itemize}

\hypertarget{bandersnatch-cipher-suite}{%
\subsection{3.3. Bandersnatch Cipher
Suite}\label{bandersnatch-cipher-suite}}

Suite specification follows RFC9381 section 5.5 guidelines.

\begin{itemize}
\item
  The EC group \(\langle G \rangle\) is the Bandersnatch elliptic curve,
  in Twisted Edwards form, with the finite field and curve parameters as
  specified in the
  \href{https://neuromancer.sk/std/bls/Bandersnatch}{neuromancer}
  standard curves database. For this group, \texttt{fLen} =
  \texttt{qLen} = 32 and \texttt{cofactor} = 4.
\item
  The prime subgroup generator \(G\) is constructed following
  \emph{Zcash}'s guidelines: \emph{``The generators of \(G1\) and \(G2\)
  are computed by finding the lexicographically smallest valid
  x-coordinate, and its lexicographically smallest y-coordinate and
  scaling it by the cofactor such that the result is not the point at
  infinity.''}

  \begin{itemize}
  \tightlist
  \item
    \(G.x\) =
    \texttt{0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18}
  \item
    \(G.y\) =
    \texttt{0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166}
  \end{itemize}
\item
  The public key generation primitive is \(pk = sk \cdot G\), with
  \(sk\) the secret key scalar and \(G\) the group generator. In this
  ciphersuite, the secret scalar \texttt{x} is equal to the secret key
  \texttt{sk}.
\item
  \texttt{suite\_string} = 0x33.
\item
  \texttt{cLen} = 32.
\item
  \texttt{encode\_to\_curve\_salt} = \texttt{pk\_string}
  (\(Encode(pk)\)).
\item
  The \texttt{ECVRF\_nonce\_generation} function is as specified in
  Section 5.4.2.1 of RFC-9381.
\item
  The \texttt{int\_to\_string} function encodes into the 32 bytes little
  endian representation.
\item
  The \texttt{string\_to\_int} function decodes from the 32 bytes little
  endian representation.
\item
  The point\_to\_string function converts a point on E to an octet
  string using compressed form. The Y coordinate is encoded using
  \texttt{int\_to\_string} function and the most significant bit of the
  last octet is used to keep track of the X's sign. This implies that
  the point is encoded on 32 bytes.
\item
  The string\_to\_point function tries to decompress the point encoded
  according to \texttt{point\_to\_string} procedure. This function MUST
  outputs ``INVALID'' if the octet string does not decode to a point on
  the curve E.
\item
  The hash function Hash is SHA-512 as specified in
  \href{https://www.rfc-editor.org/rfc/rfc6234}{RFC6234}, with hLen =
  64.
\item
  The \texttt{ECVRF\_encode\_to\_curve} function (\emph{Elligator2}) is
  as specified in Section 5.4.1.2, with \texttt{h2c\_suite\_ID\_string}
  = \texttt{"BANDERSNATCH\_XMD:SHA-512\_ELL2\_RO\_"}. The suite must be
  interpreted as defined by Section 8.5 of
  \href{https://datatracker.ietf.org/doc/rfc9380/}{RFC9380} and using
  the domain separation tag
  \texttt{DST\ =\ "ECVRF\_"\ \textbar{}\textbar{}\ h2c\_suite\_ID\_string\ \textbar{}\textbar{}\ suite\_string}.
\end{itemize}

\hypertarget{pedersen-vrf}{%
\section{4. Pedersen VRF}\label{pedersen-vrf}}

Pedersen VRF resembles EC VRF but replaces the public key by a Pedersen
commitment to the secret key, which makes the Pedersen VRF useful in
anonymized ring VRFs (See {[}Pedersen Ring VRF{]}).

Strictly speaking Pederson VRF is not a VRF. Instead, it proves that the
output has been generated with a secret key associated with a blinded
public (instead of public key). The blinded public key is a
cryptographic commitment to the public key. And it could unblinded to
prove that the output of the VRF is corresponds to the public key of the
signer.

\hypertarget{setup}{%
\subsection{4.1. Setup}\label{setup}}

PedersenVRF is initiated for prime subgroup \(G\) of an elliptic curve E
with \(K, B \in G\) defined to be \emph{key base} and \emph{blinding
base} respectively.

\begin{itemize}
\tightlist
\item
  K is set equal to point \(g\) defined in {[}Bandersnatch Cipher
  Suite{]}.
\item
  B is defined as:

  \begin{itemize}
  \tightlist
  \item
    \(b.x\) =
    \texttt{0x2039d9bf2ecb2d4433182d4a940ec78d34f9d19ec0d875703d4d04a168ec241e}
  \item
    \(b.y\) =
    \texttt{0x54fa7fd5193611992188139d20221028bf03ee23202d9706a46f12b3f3605faa}
  \end{itemize}
\end{itemize}

In twisted Edwards coordinates.

\hypertarget{sign-1}{%
\subsubsection{4.2. Sign}\label{sign-1}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(sk\): VRF secret key \(\in F\).
\item
  \(sb\): Blinding factor \(\in F\) (can be random)
\item
  \(input\): \(VRFInput \in G\).
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  A quintuple \((preout, compk, KBrand, PORand, ks, bs)\) corresponding
  to Pedersen VRF signature.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(preout = sk \cdot input\)
\item
  \(krand \leftarrow RandomElement(F)\)
\item
  \(brand \leftarrow RandomElement(F)\)
\item
  \(KBrand \leftarrow krand \cdot G + brand \cdot B\)
\item
  \(POrand \leftarrow krand \cdot input\)
\item
  \(compk = sk \cdot K + sb \cdot B\)
\item
  \(c \rightarrow Challenge(compk, KBrand, POrand, ad)\)
\item
  \(ks \rightarrow krand + c \cdot sk\)
\item
  \(bs \rightarrow brand + c \cdot sb\)
\item
  \textbf{return} \((preout, compk, KBrand, PORand, ks, bs)\)
\end{enumerate}

\hypertarget{verify-1}{%
\subsection{4.3. Verify}\label{verify-1}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(pk\): VRF verification key corresponds to \(sk\) \(\in G\).
\item
  \(input\): \(VRFInput \in G\).
\item
  \(preout\): \(VRFPreOutput \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \((compk, KBrand, PORand, ks, bs)\) proof yielded by \(Sign\).
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(c \rightarrow Challenge(compk, KBrand, POrand, ad)\)
\item
  \(z1 \leftarrow POrand + c \cdot preout - input \cdot ks\)
\item
  \(z1 \leftarrow ClearCofactor(z1)\)
\item
  \textbf{if} \(z1 \neq O\) \textbf{then} \textbf{return} False
\item
  \(z2 \leftarrow KBrand + c \cdot compk - krand \cdot K - brand \cdot B\)
\item
  \(z2 \leftarrow ClearCofactor(z2)\)
\item
  \textbf{if} \(z2 \neq O\) \textbf{then} \textbf{return} False
\item
  \textbf{return} True
\end{enumerate}

NOTE: I don't think step 3 and 6 are necessary, we're working in the
prime subgroup.

\hypertarget{challenge}{%
\subsection{4.4. Challenge}\label{challenge}}

Defined similarly to the procedure specified by section 5.4.3 of
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381}.

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(points\): Sequence of points to include in the challenge.
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  Scalar \in F.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(str\) = \texttt{"pedersen\_vrf"}
\item
  \textbf{for} \(p\) \textbf{in} \(points\):
  \(str = str \Vert PointToString(obj)\)
\item
  \(str = str \Vert ad \Vert 0x00\)
\item
  \(h = Sha512(str)\)
\item
  \(ht = h[0] .. h[31]\)
\item
  \(c = StringToInt(ht)\)
\item
  \textbf{return} \(c\)
\end{enumerate}

With \(PointToString\) and \(StringToInto\) defined as
\texttt{point\_to\_string} and \texttt{string\_to\_int} in
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} with
configuration specified in the {[}IETF VRF{]} section of this document.

\hypertarget{pedersen-ring-vrf}{%
\section{5. Pedersen Ring VRF}\label{pedersen-ring-vrf}}

Anonymized ring VRFs based of {[}Pedersen VRF{]} and \ldots{}

\hypertarget{setup-1}{%
\subsection{5.1. Setup}\label{setup-1}}

Setup for plain {[}Pedersen VRF{]} applies.

TODO: - SRS for zk-SNARK definition - All the details

\hypertarget{sign-2}{%
\subsection{5.2. Sign}\label{sign-2}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(sk\): VRF secret key.
\item
  \(sb\): Blinding factor \(\in F\) (can be random)
\item
  \(input\): \(VRFInput \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \(P\): ring prover key
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  \((preout, pedersen-proof, zk-proof)\)
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \((preout, pedersen-proof) \leftarrow PedersenSign(sk, sb, input, ad)\)
\item
  ring-proof: TODO
\end{enumerate}

\hypertarget{verify-2}{%
\subsection{5.3. Verify}\label{verify-2}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(pk\): VRF verification key corresponds to \(sk\) \(\in G\).
\item
  \(input\): \(VRFInput \in G\).
\item
  \(preout\): \(VRFPreOutput \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \(P\): ring prover key
\item
  \((pproof, rproof)\) proofs yielded by \(Sign\).
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{itemize}
\tightlist
\item
  PedersenVerify(pk, input, preout, ad, pedersen-proof)
\item
  verify ring-proof
\end{itemize}

\hypertarget{references}{%
\section{6. References}\label{references}}

TODO

\end{document}
