% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Bandersnatch VRF-AD Specification},
  pdfauthor={Seyed Hosseini; Davide Galassi},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newlength{\cslentryspacingunit} % times entry-spacing
\setlength{\cslentryspacingunit}{\parskip}
\newenvironment{CSLReferences}[2] % #1 hanging-ident, #2 entry spacing
 {% don't indent paragraphs
  \setlength{\parindent}{0pt}
  % turn on hanging indent if param 1 is 1
  \ifodd #1
  \let\oldpar\par
  \def\par{\hangindent=\cslhangindent\oldpar}
  \fi
  % set entry spacing
  \setlength{\parskip}{#2\cslentryspacingunit}
 }%
 {}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{#1\hfill\break}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{#1}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{#1}\break}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Bandersnatch VRF-AD Specification}
\author{Seyed Hosseini \and Davide Galassi}
\date{}

\begin{document}
\maketitle

Draft 2 - 04-04-2024

\newcommand{\G}{\langle G \rangle}
\newcommand{\F}{\mathbb{Z}^*_r}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{abstract}{%
\section{\texorpdfstring{\emph{Abstract}}{Abstract}}\label{abstract}}

This technical specification introduces the Verifiable Random Function
with Additional Data (VRF-AD), a cryptographic construct that extends
the capabilities of the IETF's Elliptic Curve Verifiable Random
Functions (ECVRF) as defined in
\href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} {[}1{]}. The
document also discusses the Pedersen VRF, a novel variation proposed by
\href{https://eprint.iacr.org/2023/002}{Burdges} {[}2{]}, which serves
as a fundamental component for implementing anonymized ring signatures.
Additionally, the specification provides detailed insights into the
usage of these primitives within the
\href{https://eprint.iacr.org/2021/1152}{Bandersnatch} {[}3{]}, an
elliptic curve constructed over the BLS12-381 scalar field.

\hypertarget{introduction}{%
\section{1. Introduction}\label{introduction}}

\textbf{Definition}: A \emph{verifiable random function with additional
data (VRF-AD)} can be described with two functions:

\begin{itemize}
\tightlist
\item
  \(Sign(sk,msg,ad) \mapsto \pi\) : from a secret key \(sk\), an input
  \(msg\), and additional data \(ad\), and returns a signature \(\pi\).
\item
  \(Verify(pk,msg,ad,\pi) \mapsto (out|prep)\) : for a public key
  \(pk\), an input \(msg\), additional data \(ad\), and VRF signature
  \(\pi\) returns either an output \(out\) or else a failure \(perp\).
\end{itemize}

\textbf{Definition}: For an elliptic curve \(E\) defined over finite
field \(\mathbb{F}_p\) with large subgroup \(\langle G \rangle\) with
prime order \(r\) generated by the base point \(G\), an EC-VRF is VRF-AD
where \(pk = sk \cdot G\) and VRF \(Sign\) is based on an elliptic curve
signature scheme.

All VRFs described in this specification are EC-VRF.

\hypertarget{preliminaries}{%
\section{2. Preliminaries}\label{preliminaries}}

\hypertarget{vrf-input}{%
\subsection{2.1. VRF Input}\label{vrf-input}}

A point in \(\langle G \rangle\) and generated using a \(msg\)
octet-string via the \emph{Elligator 2} \emph{hash-to-curve} algorithm
described by section 6.8.2 of
\href{https://datatracker.ietf.org/doc/rfc9380}{RFC9380} {[}4{]}.

Refer to {[}Bandersnatch Cipher Suite{]} for configuration details.

\hypertarget{vrf-output}{%
\subsection{2.2. VRF Output}\label{vrf-output}}

A point in \(G\) generated using VRF input point as:
\(Output \leftarrow sk \cdot Input\).

\hypertarget{vrf-hashed-output}{%
\subsection{2.3. VRF Hashed Output}\label{vrf-hashed-output}}

A fixed length octet-string generated using VRF output point.

The generation procedure details are specified by the proof-to-hash
procedure in section 5.2 of
\href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} and the output
length depends on the used hasher

Refer to {[}Bandersnatch Cipher Suite{]} for configuration details.

\hypertarget{ietf-vrf}{%
\section{3. IETF VRF}\label{ietf-vrf}}

Definition of a VRF based on the IETF
\href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} specification.

This VRF faithfully follows the RFC but extends it with the capability
to sign additional user data (\texttt{ad}) as per our definition of
VRF-AD.

In particular, \emph{step 5} of RFC section 5.4.3 is defined as:

\begin{verbatim}
str = str || ad || challenge_generation_domain_separator_back
\end{verbatim}

\hypertarget{setup}{%
\subsection{3.1. Setup}\label{setup}}

Setup follows from the \emph{``cipher suite''} specification defined by
faithfully following the
\href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} section 5.5
guidelines and naming conventions.

\begin{itemize}
\item
  The EC group \(\langle G \rangle\) is the prime subgroup of the
  Bandersnatch elliptic curve, in Twisted Edwards form, with the finite
  field and curve parameters as specified in the {[}neuromancer{]}
  standard curves database. For this group, \texttt{fLen} =
  \texttt{qLen} = 32 and \texttt{cofactor} = 4.
\item
  The prime subgroup generator \(G\) is constructed following
  \emph{Zcash}'s guidelines: \emph{``The generators of \(G1\) and \(G2\)
  are computed by finding the lexicographically smallest valid
  x-coordinate, and its lexicographically smallest y-coordinate and
  scaling it by the cofactor such that the result is not the point at
  infinity.''}

  \begin{itemize}
  \tightlist
  \item
    \(G.x\) :=
    \texttt{0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18}
  \item
    \(G.y\) :=
    \texttt{0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166}
  \end{itemize}
\item
  The public key generation primitive is \(pk = sk \cdot G\), with
  \(sk\) the secret key scalar and \(G\) the group generator. In this
  ciphersuite, the secret scalar \texttt{x} is equal to the secret key
  \texttt{sk}.
\item
  \texttt{suite\_string} = 0x33.
\item
  \texttt{cLen} = 32.
\item
  \texttt{encode\_to\_curve\_salt} = \texttt{pk\_string}
  (i.e.~\(Encode(pk)\)).
\item
  The \texttt{ECVRF\_nonce\_generation} function is specified in Section
  5.4.2.1 of \href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381}.
\item
  The \texttt{int\_to\_string} function encodes into the 32 bytes little
  endian representation.
\item
  The \texttt{string\_to\_int} function decodes from the 32 bytes little
  endian representation.
\item
  The point\_to\_string function converts a point in
  \(\langle G \rangle\) to an octet string using compressed form. The
  \(y\) coordinate is encoded using \texttt{int\_to\_string} function
  and the most significant bit of the last octet is used to keep track
  of the \(x\)'s sign. This implies that the point is encoded in 32
  bytes.
\item
  The string\_to\_point function tries to decompress the point encoded
  according to \texttt{point\_to\_string} procedure. This function MUST
  outputs ``INVALID'' if the octet string does not decode to a point on
  the prime subgroup \(\langle G \rangle\).
\item
  The hash function Hash is SHA-512 as specified in
  \href{https://www.rfc-editor.org/rfc/rfc6234}{RFC6234}, with
  \texttt{hLen} = 64.
\item
  The \texttt{ECVRF\_encode\_to\_curve} function (\emph{Elligator2}) is
  as specified in Section 5.4.1.2, with \texttt{h2c\_suite\_ID\_string}
  = \texttt{"BANDERSNATCH\_XMD:SHA-512\_ELL2\_RO\_"}. The suite must be
  interpreted as defined by Section 8.5 of {[}4{]} and using the domain
  separation tag
  \texttt{DST\ =\ "ECVRF\_"\ \textbar{}\textbar{}\ h2c\_suite\_ID\_string\ \textbar{}\textbar{}\ suite\_string}.
\end{itemize}

\hypertarget{sign}{%
\subsection{3.2. Sign}\label{sign}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(x\): Secret key \(\in \mathbb{Z}^*_r\)
\item
  \(I\): VRF Input \(\in \langle G \rangle\)
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Outputs}:

\begin{itemize}
\tightlist
\item
  \(O\): VRF Output \(\in \langle G \rangle\)
\item
  \(\pi\): \emph{Schnorr-like} proof
  \(\in (\mathbb{Z}^*_r, \mathbb{Z}^*_r)\)
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(O \leftarrow x \cdot I\)
\item
  \(Y \leftarrow x \cdot G\)
\item
  \(k \leftarrow nonce(x, I)\)
\item
  \(c \leftarrow challenge(Y, I, O, k \cdot G, k \cdot I, ad)\)
\item
  \(s \leftarrow (k + c \cdot x)\)
\item
  \(\pi \leftarrow (c, s)\)
\item
  \textbf{return} \((O, \pi)\)
\end{enumerate}

\textbf{Externals}:

\begin{itemize}
\tightlist
\item
  \(nonce\): refer to
  \href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} section 5.4.2
\item
  \(challenge\): refer to
  \href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} section 5.4.3
\end{itemize}

\hypertarget{verify}{%
\subsection{3.3. Verify}\label{verify}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(Y\): Public key \(\in \langle G \rangle\)
\item
  \(I\): VRF Input \(\in \langle G \rangle\)
\item
  \(ad\): Additional data octet-string
\item
  \(O\): VRF Output \(\in \langle G \rangle\)
\item
  \(\pi\): As defined for \(Sign\) output.
\end{itemize}

\textbf{Outputs}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \((c, s) \leftarrow \pi\)
\item
  \(U \leftarrow s \cdot K - c \cdot Y\)
\item
  \(V \leftarrow s \cdot H - c \cdot O\)
\item
  \(c' \leftarrow challenge(Y, I, O, U, V, ad)\)
\item
  \textbf{if} \(c \neq c'\) \textbf{then} \textbf{return} False
\item
  \textbf{return} True
\end{enumerate}

\textbf{Externals}:

\begin{itemize}
\tightlist
\item
  \(challenge\): as defined for \(Sign\)
\end{itemize}

\hypertarget{pedersen-vrf}{%
\section{4. Pedersen VRF}\label{pedersen-vrf}}

Pedersen VRF resembles IETF VRF but replaces the public key by a
Pedersen commitment to the secret key, which makes the Pedersen VRF
useful in anonymized ring VRFs (see {[}Pedersen Ring VRF{]}).

Strictly speaking Pederson VRF is not a VRF. Instead, it proves that the
output has been generated with a secret key associated with a blinded
public (instead of public key). The blinded public key is a
cryptographic commitment to the public key. And it could be unblinded to
prove that the output of the VRF corresponds to the public key of the
signer.

\hypertarget{setup-1}{%
\subsection{4.1. Setup}\label{setup-1}}

Pedersen VRF is initiated for prime subgroup \(\langle G \rangle\) of an
elliptic curve \(E\) with \emph{blinding base}
\(B \in \langle G \rangle\) defined as:

\begin{itemize}
\tightlist
\item
  \(B.x\) :=
  \texttt{0x2039d9bf2ecb2d4433182d4a940ec78d34f9d19ec0d875703d4d04a168ec241e}
\item
  \(B.y\) :=
  \texttt{0x54fa7fd5193611992188139d20221028bf03ee23202d9706a46f12b3f3605faa}
\end{itemize}

In twisted Edwards coordinates.

For all the other configurable parameters and external functions we'll
pick as much as possible from the {[}Bandersnatch Cipher Suite{]}
specification for IETF VRF.

\hypertarget{sign-1}{%
\subsubsection{4.2. Sign}\label{sign-1}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(x\): Secret key \(\in \mathbb{Z}^*_r\)
\item
  \(I\): VRF Input \(\in \langle G \rangle\)
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  \(O\): VRF \(Output \in \langle G \rangle\)
\item
  \(\pi\): Pedersen proof
  \(\in (\langle G \rangle, \langle G \rangle, \langle G \rangle, \mathbb{Z}^*_r, \mathbb{Z}^*_r)\)
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(O \leftarrow x \cdot I\)
\item
  \((b, k, k_b) \leftarrow random()\)
\item
  \(Y_c \leftarrow x \cdot G + b \cdot B\)
\item
  \(KB_r \leftarrow k \cdot G + k_b \cdot B\)
\item
  \(O_k \leftarrow k \cdot I\)
\item
  \(c \leftarrow challenge(Y_c, KB_r, O_k, ad)\)
\item
  \(s \leftarrow k + c \cdot x\)
\item
  \(s_b \leftarrow k_b + c \cdot b\)
\item
  \(\pi \leftarrow (Y_c, KB_r, O_k, s, s_b)\)
\item
  \textbf{return} \((O, \pi)\)
\end{enumerate}

\textbf{Externals}:

\begin{itemize}
\tightlist
\item
  \(challenge\): see {[}Challenge{]} section
\item
  \(random\): generates random scalars in \(\mathbb{Z}^*_r\)
\end{itemize}

\hypertarget{verify-1}{%
\subsection{4.3. Verify}\label{verify-1}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(I\): VRF Input \(\in \langle G \rangle\).
\item
  \(O\): VRF Output \(\in \langle G \rangle\).
\item
  \(ad\): Additional data octet-string
\item
  \(\pi\): Pedersen proof as defined for \(Sign\).
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \((Y_c, KB_r, O_k, s, s_b) \leftarrow \pi\)
\item
  \(c \leftarrow challenge(Y_c, KB_r, O_k, ad)\)
\item
  \(z_1 \leftarrow O_k + c \cdot O - I \cdot s\)
\item
  \textbf{if} \(z_1 \neq O\) \textbf{then} \textbf{return} False
\item
  \(z_2 \leftarrow KB_r + c \cdot Y_c - s \cdot G - s_b \cdot B\)
\item
  \textbf{if} \(z_2 \neq O\) \textbf{then} \textbf{return} False
\item
  \textbf{return} True
\end{enumerate}

\textbf{Externals}:

\begin{itemize}
\tightlist
\item
  \(challenge\): see {[}Challenge{]} section
\end{itemize}

\hypertarget{challenge}{%
\subsection{4.4. Challenge}\label{challenge}}

Defined similarly to the challenge procedure specified by section 5.4.3
of \href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381}.

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(Points\): Sequence of points \(\in \langle G \rangle\).
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  \(c\): Challenge \(\in \mathbb{Z}^*_r\).
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(str\) = \texttt{"pedersen\_vrf"} (ASCII encoded octet-string)
\item
  \textbf{for} \(P\) \textbf{in} \(Points\):
  \(str = str \Vert PointToString(P)\)
\item
  \(str = str \Vert ad \Vert 0x00\)
\item
  \(h = Sha512(str)\)
\item
  \(h_t = h[0] \Vert .. \Vert h[31]\)
\item
  \(c = StringToInt(h_t)\)
\item
  \textbf{return} \(c\)
\end{enumerate}

With \(PointToString\) and \(StringToInt\) defined as
\texttt{point\_to\_string} and \texttt{string\_to\_int} from
\href{https://datatracker.ietf.org/doc/rfc9381}{RFC9381} respectively.

\hypertarget{pedersen-ring-vrf}{%
\section{5. Pedersen Ring VRF}\label{pedersen-ring-vrf}}

Anonymized ring VRFs based of {[}Pedersen VRF{]} and \ldots{}

\hypertarget{setup-2}{%
\subsection{5.1. Setup}\label{setup-2}}

Setup for plain {[}Pedersen VRF{]} applies.

TODO: - SRS for zk-SNARK definition - All the details

\hypertarget{sign-2}{%
\subsection{5.2. Sign}\label{sign-2}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(x\): Secret key \(\in \mathbb{Z}^*_r\).
\item
  \(I\): VRF Input \(\in \langle G \rangle\).
\item
  \(ad\): Additional data octet-string
\item
  \(P\): Ring prover key
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  \(O\): VRF Output \(\in \langle G \rangle\).
\item
  \(\pi_p\): Pedersen proof as specified in {[}Pedersen VRF{]}.
\item
  \(\pi_r\): Ring proof as specified in
  \href{https://hackmd.io/ulW5nFFpTwClHsD0kusJAA}{Sergey}
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \((O, \pi_p) \leftarrow Pedersen.Sign(x, I, ad)\)
\item
  \(\pi_r \leftarrow Ring.Prove(P, ...)\) (TODO)
\end{enumerate}

\hypertarget{verify-2}{%
\subsection{5.3. Verify}\label{verify-2}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(I\): VRF Input \(\in \langle G \rangle\).
\item
  \(O\): VRF Output \(\in \langle G \rangle\).
\item
  \(ad\): Additional data octet-string
\item
  \(V\): ring verifier key \(\in ?\)
\item
  \(\pi_p\): Pedersen proof as defined in Pedersen VRF.
\item
  \(\pi_r\): Ring proof as defined in
  \href{https://hackmd.io/ulW5nFFpTwClHsD0kusJAA}{Sergey}
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{itemize}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \(r = Pedersen.Verify(I, O, ad, \pi_p)\)
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{1}
  \tightlist
  \item
    \textbf{if} \(r \neq True\) \textbf{return} False
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{2}
  \tightlist
  \item
    \(r = Ring.Verify(V, \pi_r, ...)\) (TODO)
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{3}
  \tightlist
  \item
    \textbf{if} \(r \neq True\) \textbf{return} False
  \end{enumerate}
\item
  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \setcounter{enumi}{3}
  \tightlist
  \item
    \textbf{return} True
  \end{enumerate}
\end{itemize}

\hypertarget{references}{%
\section*{6. References}\label{references}}
\addcontentsline{toc}{section}{6. References}

\hypertarget{refs}{}
\begin{CSLReferences}{0}{0}
\leavevmode\vadjust pre{\hypertarget{ref-RFC9381}{}}%
\CSLLeftMargin{1. }
\CSLRightInline{Internet Engineering Task Force (2023)
\href{https://datatracker.ietf.org/doc/rfc9381}{{Verifiable Random
Functions}}. {RFC Editor}}

\leavevmode\vadjust pre{\hypertarget{ref-Burdges}{}}%
\CSLLeftMargin{2. }
\CSLRightInline{Burdges J, Ciobotaru O, Alper HK, et al (2023)
\href{https://eprint.iacr.org/2023/002}{Ring verifiable random functions
and zero-knowledge continuations}}

\leavevmode\vadjust pre{\hypertarget{ref-Bandersnatch}{}}%
\CSLLeftMargin{3. }
\CSLRightInline{Masson S, Sanso A, Zhang Z (2021)
\href{https://eprint.iacr.org/2021/1152}{Bandersnatch: A fast elliptic
curve built over the BLS12-381 scalar field}}

\leavevmode\vadjust pre{\hypertarget{ref-RFC9380}{}}%
\CSLLeftMargin{4. }
\CSLRightInline{Internet Engineering Task Force (2023)
\href{https://datatracker.ietf.org/doc/rfc9380}{{Hashing to Elliptic
Curves}}. {RFC Editor}}

\end{CSLReferences}

\end{document}
