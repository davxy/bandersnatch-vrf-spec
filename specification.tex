% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{article}
\usepackage{amsmath,amssymb}
\usepackage{lmodern}
\usepackage{iftex}
\ifPDFTeX
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Bandersnatch VRF-AD Specification},
  pdfauthor={Seyed Hosseini; Davide Galassi},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{-\maxdimen} % remove section numbering
\ifLuaTeX
  \usepackage{selnolig}  % disable illegal ligatures
\fi

\title{Bandersnatch VRF-AD Specification}
\author{Seyed Hosseini \and Davide Galassi}
\date{}

\begin{document}
\maketitle

Draft 2 - 04-04-2024

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\hypertarget{introduction}{%
\section{Introduction}\label{introduction}}

\textbf{Definition}: A \emph{verifiable random function with additional
data (VRF-AD)} can be described with two functions:

\begin{itemize}
\tightlist
\item
  \(Sign(sk,msg,ad) \mapsto \pi\) : from a secret key \(sk\), an input
  \(msg\), and additional data \(ad\), and returns a signature \(\pi\).
\item
  \(Verify(pk,msg,ad,\pi) \mapsto (out|prep)\) : for a public key
  \(pk\), an input \(msg\), additional data \(ad\), and VRF signature
  \(\pi\) returns either an output \(out\) or else a failure \(perp\).
\end{itemize}

\textbf{Definition}: For an elliptic curve \(E\) defined over finite
field \(F\) with large prime subgroup \(G\) with order \(r\) generated
by the base point \(B\), an EC-VRF is VRF-AD where \(pk = sk \cdot g\)
and VRF \(Sign\) is based on an elliptic curve signature scheme.

All VRFs described in this specification are EC-VRF.

\hypertarget{preliminaries}{%
\section{Preliminaries}\label{preliminaries}}

\hypertarget{vrf-input}{%
\subsection{VRF Input}\label{vrf-input}}

A point on \(E\) and generated using \(msg\) octet-string via the
\emph{Elligator 2} hash-to-curve algorithm described by section 6.8.2 of
\href{https://datatracker.ietf.org/doc/rfc9380/}{RFC9380}.

The algorithm yields a point in \(G\).

\hypertarget{vrf-output}{%
\subsection{VRF Output}\label{vrf-output}}

A point generated using VRF input point as:

\[Output \leftarrow sk \cdot Input\]

\hypertarget{vrf-hashed-output}{%
\subsection{VRF Hashed Output}\label{vrf-hashed-output}}

An fixed length octet-string generated using VRF output point.

The generation procedure details are specified by the proof-to-hash
procedure in section 5.2 of
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} and the output
length depends on the used hasher (see
\protect\hyperlink{bandersnatch-cipher-suite}{Bandersnatch Cipher Suite}
for details).

\hypertarget{ietf-vrf}{%
\section{IETF VRF}\label{ietf-vrf}}

Definition of a VRF based on the IETF
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381}.

All the details specified by the RFC applies with the additional
capability to sign additional data (\texttt{ad}) as per definition of
VRF-AD we've given.

In particular \emph{step 5} of section 5.4.3 is defined as:

\begin{verbatim}
str = str || ad || challenge_generation_domain_separator_back
\end{verbatim}

\hypertarget{setup}{%
\subsection{Setup}\label{setup}}

IETF VRF is initiated for prime subgroup \(G\) of an elliptic curve
\(E\) with \(K \in G\) defined to be \emph{key base} respectively.

\hypertarget{sign}{%
\subsection{Sign}\label{sign}}

\[ Sign(sk, input, ad) \mapsto (output, proof) \]

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(sk\): secret key \(\in \mathbb{Z}^*_r\).
\item
  \(input\): \(Input \in G\).
\item
  \(ad\): Additional data octet-string.
\end{itemize}

\textbf{Outputs}:

\begin{itemize}
\tightlist
\item
  \(preout\): \(PreOutput \in G\)
\item
  \(proof\): A \emph{Schnorr-like} proof
  \(\in (\mathbb{Z}^*_r, \mathbb{Z}^*_r)\)
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(preout = sk \cdot input\)
\item
  \(k \leftarrow Nonce(sk, input)\) (see
  \href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} section
  5.4.2)
\item
  \(c \leftarrow Challenge(Y, H, preout, k \cdot B, k \cdot input)\)
  (see \href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} section
  5.4.3)
\item
  \(s \leftarrow (k + c \cdot x)\)
\item
  \(proof \leftarrow (c, s)\)
\item
  \textbf{return} \((preout, proof)\)
\end{enumerate}

\hypertarget{verify}{%
\subsection{Verify}\label{verify}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(pk\): verification key corresponds to \(sk\) \(in G\).
\item
  \(input\): \(Input \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \(output\): \(Output \in G\).
\item
  \(proof\): as defined for \(Sign\) output.
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(U = s \cdot K - c \cdot pk\)
\item
  \(V = s \cdot H - c \cdot preout\)
\item
  \(c' = Challenge(pk, input, output, U, V)\) (see
  \href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} Section
  5.4.3)
\item
  \textbf{if} \(c \neq c'\) \textbf{then} \textbf{return} False
\item
  \textbf{return} True
\end{enumerate}

\hypertarget{bandersnatch-cipher-suite}{%
\subsection{Bandersnatch Cipher Suite}\label{bandersnatch-cipher-suite}}

Suite specification follows RFC9381 section 5.5 guidelines.

\begin{itemize}
\item
  The EC group G is the Bandersnatch elliptic curve, in Twisted Edwards
  form, with the finite field and curve parameters as specified in the
  \href{https://neuromancer.sk/std/bls/Bandersnatch}{neuromancer}
  standard curves database. For this group, \texttt{fLen} =
  \texttt{qLen} = 32 and \texttt{cofactor} = 4.
\item
  The prime subgroup generator \texttt{g} is constructed following
  \emph{Zcash}'s guidelines: \emph{``The generators of G1 and G2 are
  computed by finding the lexicographically smallest valid x-coordinate,
  and its lexicographically smallest y-coordinate and scaling it by the
  cofactor such that the result is not the point at infinity.''}

  \begin{itemize}
  \tightlist
  \item
    \(g.x\) =
    \texttt{0x29c132cc2c0b34c5743711777bbe42f32b79c022ad998465e1e71866a252ae18}
  \item
    \(g.y\) =
    \texttt{0x2a6c669eda123e0f157d8b50badcd586358cad81eee464605e3167b6cc974166}
  \end{itemize}
\item
  The public key generation primitive is
  \texttt{pk\ =\ sk\ \textbackslash{}cdot\ g}, with \(sk\) the secret
  key scalar and \(g\) the group generator. In this ciphersuite, the
  secret scalar \texttt{x} is equal to the secret key \texttt{sk}.
\item
  \texttt{suite\_string} = 0x33.
\item
  \texttt{cLen} = 32.
\item
  \texttt{encode\_to\_curve\_salt} = \texttt{pk\_string}.
\item
  The \texttt{ECVRF\_nonce\_generation} function is as specified in
  Section 5.4.2.1 of RFC-9381.
\item
  The \texttt{int\_to\_string} function encodes into the 32 bytes little
  endian representation.
\item
  The \texttt{string\_to\_int} function decodes from the 32 bytes little
  endian representation.
\item
  The point\_to\_string function converts a point on E to an octet
  string using compressed form. The Y coordinate is encoded using
  \texttt{int\_to\_string} function and the most significant bit of the
  last octet is used to keep track of the X's sign. This implies that
  the point is encoded on 32 bytes.
\item
  The string\_to\_point function tries to decompress the point encoded
  according to \texttt{point\_to\_string} procedure. This function MUST
  outputs ``INVALID'' if the octet string does not decode to a point on
  the curve E.
\item
  The hash function Hash is SHA-512 as specified in
  \href{https://www.rfc-editor.org/rfc/rfc6234}{RFC6234}, with hLen =
  64.
\item
  The \texttt{ECVRF\_encode\_to\_curve} function (\emph{Elligator2}) is
  as specified in Section 5.4.1.2, with \texttt{h2c\_suite\_ID\_string}
  = \texttt{"BANDERSNATCH\_XMD:SHA-512\_ELL2\_RO\_"}. The suite must be
  interpreted as defined by Section 8.5 of
  \href{https://datatracker.ietf.org/doc/rfc9380/}{RFC9380} and using
  the domain separation tag
  \texttt{DST\ =\ "ECVRF\_"\ \textbar{}\textbar{}\ h2c\_suite\_ID\_string\ \textbar{}\textbar{}\ suite\_string}.
\end{itemize}

\hypertarget{pedersen-vrf}{%
\section{Pedersen VRF}\label{pedersen-vrf}}

Pedersen VRF resembles EC VRF but replaces the public key by a Pedersen
commitment to the secret key, which makes the Pedersen VRF useful in
anonymized ring VRFs (See \protect\hyperlink{pedersen-ring-vrf}{Pedersen
Ring VRF}).

Strictly speaking Pederson VRF is not a VRF. Instead, it proves that the
output has been generated with a secret key associated with a blinded
public (instead of public key). The blinded public key is a
cryptographic commitment to the public key. And it could unblinded to
prove that the output of the VRF is corresponds to the public key of the
signer.

\hypertarget{setup-1}{%
\subsection{Setup}\label{setup-1}}

PedersenVRF is initiated for prime subgroup \(G\) of an elliptic curve E
with \(K, B \in G\) defined to be \emph{key base} and \emph{blinding
base} respectively.

\begin{itemize}
\tightlist
\item
  K is set equal to point \(g\) defined in
  \protect\hyperlink{bandersnatch-cipher-suite}{Bandersnatch Cipher
  Suite}.
\item
  B is defined as:

  \begin{itemize}
  \tightlist
  \item
    \(b.x\) =
    \texttt{0x2039d9bf2ecb2d4433182d4a940ec78d34f9d19ec0d875703d4d04a168ec241e}
  \item
    \(b.y\) =
    \texttt{0x54fa7fd5193611992188139d20221028bf03ee23202d9706a46f12b3f3605faa}
  \end{itemize}
\end{itemize}

In twisted Edwards coordinates.

\hypertarget{sign-1}{%
\subsubsection{Sign}\label{sign-1}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(sk\): VRF secret key \(\in F\).
\item
  \(sb\): Blinding factor \(\in F\) (can be random)
\item
  \(input\): \(VRFInput \in G\).
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  A quintuple \((preout, compk, KBrand, PORand, ks, bs)\) corresponding
  to Pedersen VRF signature.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(preout = sk \cdot input\)
\item
  \(krand \leftarrow RandomElement(F)\)
\item
  \(brand \leftarrow RandomElement(F)\)
\item
  \(KBrand \leftarrow krand \cdot G + brand \cdot B\)
\item
  \(POrand \leftarrow krand \cdot input\)
\item
  \(compk = sk \cdot K + sb \cdot B\)
\item
  \(c \rightarrow Challenge(compk, KBrand, POrand, ad)\)
\item
  \(ks \rightarrow krand + c \cdot sk\)
\item
  \(bs \rightarrow brand + c \cdot sb\)
\item
  \textbf{return} \((preout, compk, KBrand, PORand, ks, bs)\)
\end{enumerate}

\hypertarget{verify-1}{%
\subsection{Verify}\label{verify-1}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(pk\): VRF verification key corresponds to \(sk\) \(\in G\).
\item
  \(input\): \(VRFInput \in G\).
\item
  \(preout\): \(VRFPreOutput \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \((compk, KBrand, PORand, ks, bs)\) proof yielded by \(Sign\).
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(c \rightarrow Challenge(compk, KBrand, POrand, ad)\)
\item
  \(z1 \leftarrow POrand + c \cdot preout - input \cdot ks\)
\item
  \(z1 \leftarrow ClearCofactor(z1)\)
\item
  \textbf{if} \(z1 \neq O\) \textbf{then} \textbf{return} False
\item
  \(z2 \leftarrow KBrand + c \cdot compk - krand \cdot K - brand \cdot B\)
\item
  \(z2 \leftarrow ClearCofactor(z2)\)
\item
  \textbf{if} \(z2 \neq O\) \textbf{then} \textbf{return} False
\item
  \textbf{return} True
\end{enumerate}

NOTE: I don't think step 3 and 6 are necessary, we're working in the
prime subgroup.

\hypertarget{challenge}{%
\subsection{Challenge}\label{challenge}}

Defined similarly to the procedure specified by section 5.4.3 of
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381}.

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(points\): Sequence of points to include in the challenge.
\item
  \(ad\): Additional data octet-string
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  Scalar \in F.
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \(str\) = \texttt{"pedersen\_vrf"}
\item
  \textbf{for} \(p\) \textbf{in} \(points\):
  \(str = str \Vert PointToString(obj)\)
\item
  \(str = str \Vert ad \Vert 0x00\)
\item
  \(h = Sha512(str)\)
\item
  \(ht = h[0] .. h[31]\)
\item
  \(c = StringToInt(ht)\)
\item
  \textbf{return} \(c\)
\end{enumerate}

With \(PointToString\) and \(StringToInto\) defined as
\texttt{point\_to\_string} and \texttt{string\_to\_int} in
\href{https://datatracker.ietf.org/doc/rfc9381/}{RFC9381} with
configuration specified in the \protect\hyperlink{ietf-vrf}{IETF VRF}
section of this document.

\hypertarget{pedersen-ring-vrf}{%
\section{Pedersen Ring VRF}\label{pedersen-ring-vrf}}

Anonymized ring VRFs based of \protect\hyperlink{pedersen-vrf}{Pedersen
VRF} and \ldots{}

\hypertarget{setup-2}{%
\subsection{Setup}\label{setup-2}}

Setup for plain \protect\hyperlink{pedersen-vrf}{Pedersen VRF} applies.

TODO: - SRS for zk-SNARK definition - All the details

\hypertarget{sign-2}{%
\subsection{Sign}\label{sign-2}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(sk\): VRF secret key.
\item
  \(sb\): Blinding factor \(\in F\) (can be random)
\item
  \(input\): \(VRFInput \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \(P\): ring prover key
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  \((preout, pedersen-proof, zk-proof)\)
\end{itemize}

\textbf{Steps}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \((preout, pedersen-proof) \leftarrow PedersenSign(sk, sb, input, ad)\)
\item
  ring-proof: TODO
\end{enumerate}

\hypertarget{verify-2}{%
\subsection{Verify}\label{verify-2}}

\textbf{Inputs}:

\begin{itemize}
\tightlist
\item
  \(pk\): VRF verification key corresponds to \(sk\) \(\in G\).
\item
  \(input\): \(VRFInput \in G\).
\item
  \(preout\): \(VRFPreOutput \in G\).
\item
  \(ad\): Additional data octet-string
\item
  \(P\): ring prover key
\item
  \((pproof, rproof)\) proofs yielded by \(Sign\).
\end{itemize}

\textbf{Output}:

\begin{itemize}
\tightlist
\item
  True if proof is valid, False otherwise.
\end{itemize}

\textbf{Steps}:

\begin{itemize}
\tightlist
\item
  PedersenVerify(pk, input, preout, ad, pedersen-proof)
\item
  verify ring-proof
\end{itemize}

\hypertarget{references}{%
\section{References}\label{references}}

TODO

\end{document}
